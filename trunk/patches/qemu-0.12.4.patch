diff -Naur qemu-0.12.4+dfsg/configure qemu-0.12.4+dfsg-kemufuzzer/configure
--- qemu-0.12.4+dfsg/configure	2010-07-07 12:02:44.317616421 +0200
+++ qemu-0.12.4+dfsg-kemufuzzer/configure	2010-07-07 12:02:26.225117406 +0200
@@ -257,6 +257,7 @@
 check_utests="no"
 user_pie="no"
 zero_malloc=""
+kemufuzzer="no"
 
 # OS specific
 if check_define __linux__ ; then
@@ -518,6 +519,8 @@
   ;;
   --enable-kvm) kvm="yes"
   ;;
+  --enable-kemufuzzer) kemufuzzer="yes"
+  ;;
   --enable-profiler) profiler="yes"
   ;;
   --enable-cocoa)
@@ -753,6 +756,7 @@
 echo "  --enable-io-thread       enable IO thread"
 echo "  --disable-blobs          disable installing provided firmware blobs"
 echo "  --kerneldir=PATH         look for kernel includes in PATH"
+echo "  --enable-kemufuzzer      enable KEmuFuzzer support"
 echo ""
 echo "NOTE: The object files are built at the place where configure is launched"
 exit 1
@@ -1902,12 +1906,14 @@
 echo "preadv support    $preadv"
 echo "fdatasync         $fdatasync"
 echo "uuid support      $uuid"
+echo "KEmuFuzzer        $kemufuzzer"
 
 if test $sdl_too_old = "yes"; then
 echo "-> Your SDL version is too old - please upgrade to have SDL support"
 fi
 
 config_host_mak="config-host.mak"
+config_host_h="config-host.h"
 config_host_ld="config-host.ld"
 
 echo "# Automatically generated by configure - do not modify" > $config_host_mak
@@ -2114,6 +2120,12 @@
   echo "CONFIG_FDATASYNC=y" >> $config_host_mak
 fi
 
+# KEmuFuzzer
+if test "$kemufuzzer" = "yes" ; then
+  echo "#define CONFIG_KEMUFUZZER 1" >> $config_host_h
+  echo "CONFIG_KEMUFUZZER=y" >> $config_host_mak
+fi
+
 # XXX: suppress that
 if [ "$bsd" = "yes" ] ; then
   echo "CONFIG_BSD=y" >> $config_host_mak
diff -Naur qemu-0.12.4+dfsg/cpu-exec.c qemu-0.12.4+dfsg-kemufuzzer/cpu-exec.c
--- qemu-0.12.4+dfsg/cpu-exec.c	2010-07-07 12:02:44.337616800 +0200
+++ qemu-0.12.4+dfsg-kemufuzzer/cpu-exec.c	2010-07-07 12:02:26.245153719 +0200
@@ -44,6 +44,10 @@
 #define env cpu_single_env
 #endif
 
+#ifdef CONFIG_KEMUFUZZER
+#include "kemufuzzer.c"
+#endif
+
 int tb_invalidated_flag;
 
 //#define CONFIG_DEBUG_EXEC
@@ -220,6 +224,10 @@
     uint8_t *tc_ptr;
     unsigned long next_tb;
 
+#ifdef CONFIG_KEMUFUZZER
+    kemufuzzer_init(env1);
+#endif
+
     if (cpu_halted(env1) == EXCP_HALTED)
         return EXCP_HALTED;
 
diff -Naur qemu-0.12.4+dfsg/kemufuzzer.c qemu-0.12.4+dfsg-kemufuzzer/kemufuzzer.c
--- qemu-0.12.4+dfsg/kemufuzzer.c	1970-01-01 01:00:00.000000000 +0100
+++ qemu-0.12.4+dfsg-kemufuzzer/kemufuzzer.c	2010-07-07 12:02:26.252617662 +0200
@@ -0,0 +1,694 @@
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+#include <zlib.h>
+#include <signal.h>
+#include <linux/limits.h>
+
+#include "x86_cpustate.h"
+#define  KEMUFUZZER_PRE_STATE      0
+#define  KEMUFUZZER_POST_STATE     1
+
+#define EXPECTED_MAGIC    0xEFEF
+#define EXPECTED_VERSION  0x0001
+
+typedef struct {
+  CPUState *env;
+  int initialized;
+  int signalled;
+} t_kemufuzzer_state;
+
+int snprintf(char *str, size_t size, const char *format, ...);
+int rename(const char *oldpath, const char *newpath);
+
+inline void stw_(uint8_t *, uint16_t);
+inline void stl_(uint8_t *, uint32_t);
+inline void stq_(uint8_t *, uint64_t);
+inline uint16_t lduw_(uint8_t *);
+inline uint32_t ldl_(uint8_t *);
+inline uint64_t ldq_(uint8_t *);
+inline CPU86_LDouble fldt_(target_ulong);
+
+void fxsave_(uint8_t *);
+void fxrstor_(uint8_t *);
+void kemufuzzer_save(int, unsigned int, int);
+void kemufuzzer_load(void);
+void kemufuzzer_sigusr2_handler(int);
+void kemufuzzer_init(CPUState*);
+void kemufuzzer_ioport_start(void *opaque, uint32_t addr, uint32_t val);
+void kemufuzzer_ioport_stop(void *opaque, uint32_t addr, uint32_t val);
+void kemufuzzer_ioport_interrupt(void *opaque, uint32_t addr, uint32_t val);
+uint64_t kemufuzzer_rdmsr(uint32_t index);
+void kemufuzzer_wrmsr(uint32_t index, uint64_t val);
+
+static t_kemufuzzer_state kemufuzzer_state = {
+  .env = NULL, 
+  .initialized = 0, 
+  .signalled = 0
+};
+
+#define kenv (kemufuzzer_state.env)
+
+#define get_qemu_segment(dst, src) {			\
+    dst.base = src.base;				\
+    dst.limit = src.limit;				\
+    dst.selector = src.selector;			\
+    dst.type = (src.flags >> DESC_TYPE_SHIFT) & 15;	\
+    dst.present = (src.flags & DESC_P_MASK) != 0;	\
+    dst.dpl = src.selector & 3;				\
+    dst.db = (src.flags >> DESC_B_SHIFT) & 1;		\
+    dst.s = (src.flags & DESC_S_MASK) != 0;		\
+    dst.l = (src.flags >> DESC_L_SHIFT) & 1;		\
+    dst.g = (src.flags & DESC_G_MASK) != 0;		\
+    dst.avl = (src.flags & DESC_AVL_MASK) != 0;		\
+    dst.unusable = 0;					\
+  }
+
+#define get_qemu_table(dst, src) {		\
+    dst.base = src.base;			\
+    dst.limit = src.limit;			\
+  }
+
+#define set_qemu_segment(dst, src) {			\
+    dst.base = src.base;				\
+    dst.limit = src.limit;				\
+    dst.selector = src.selector;			\
+    dst.flags =						\
+      (src.type << DESC_TYPE_SHIFT) |			\
+      (src.s ? DESC_S_MASK : 0) |			\
+      (src.dpl  << DESC_DPL_SHIFT) |			\
+      (src.present ? DESC_P_MASK : 0) |			\
+      (src.avl ? DESC_AVL_MASK : 0) |			\
+      ((src.l != 0)    << DESC_L_SHIFT) |		\
+      ((src.db != 0)   << DESC_B_SHIFT) |		\
+      (src.g ? DESC_G_MASK : 0);			\
+  }
+
+#define set_qemu_table(dst, src) {		\
+  dst.base = src.base;				\
+  dst.limit = src.limit;			\
+  }
+
+
+inline void stw_(uint8_t *dst, uint16_t v) {
+  memcpy((void*) dst, (void*) &v, 2); 
+}
+
+inline void stl_(uint8_t *dst, uint32_t v) { 
+  memcpy((void*) dst, (void*) &v, 4); 
+}
+
+inline void stq_(uint8_t *dst, uint64_t v) { 
+  memcpy((void*) dst, (void*) &v, 8); 
+}
+
+inline uint16_t lduw_(uint8_t *dst) { 
+  return *(uint16_t*)dst;
+}
+
+inline uint32_t ldl_(uint8_t *dst) {
+  return *(uint32_t*)dst;
+}
+
+inline uint64_t ldq_(uint8_t *dst) {
+  return *(uint64_t*)dst;
+}
+
+void fxsave_(uint8_t *ptr) {
+    int fpus, fptag, i, nb_xmm_regs;
+    CPU86_LDouble tmp;
+    uint8_t *addr;
+
+    fpus = (kenv->fpus & ~0x3800) | (kenv->fpstt & 0x7) << 11;
+    fptag = 0;
+    for(i = 0; i < 8; i++) {
+        fptag |= (kenv->fptags[i] << i);
+    }
+    stw_(ptr, kenv->fpuc);
+    stw_(ptr + 2, fpus);
+    stw_(ptr + 4, fptag ^ 0xff);
+
+    addr = ptr + 0x20;
+    for(i = 0;i < 8; i++) {
+        tmp = ST(i);
+
+        /* helper_fstt(tmp, addr); */
+        {
+          CPU86_LDoubleU temp;
+          int e;
+
+          temp.d = tmp;
+          /* mantissa */
+          stq_(addr, (MANTD(temp) << 11) | (1LL << 63));
+          /* exponent + sign */
+          e = EXPD(temp) - EXPBIAS + 16383;
+          e |= SIGND(temp) >> 16;
+          stw_(addr + 8, e);
+        }
+        /* end of helper_fstt() */
+
+        addr += 16;
+    }
+
+    if (kenv->cr[4] & CR4_OSFXSR_MASK) {
+        /* XXX: finish it */
+        stl_(ptr + 0x18, kenv->mxcsr); /* mxcsr */
+        stl_(ptr + 0x1c, 0x0000ffff); /* mxcsr_mask */
+        nb_xmm_regs = 8;
+        addr = ptr + 0xa0;
+        for(i = 0; i < nb_xmm_regs; i++) {
+            stq_(addr, kenv->xmm_regs[i].XMM_Q(0));
+            stq_(addr + 8, kenv->xmm_regs[i].XMM_Q(1));
+            addr += 16;
+        }
+    }
+}
+
+inline CPU86_LDouble fldt_(target_ulong ptr)
+{
+    CPU86_LDoubleU temp;
+    temp.l.lower = ldq_((uint8_t*)&ptr);
+    temp.l.upper = lduw_((uint8_t*)(&ptr + 8));
+    return temp.d;
+}
+
+void fxrstor_(uint8_t *ptr)
+{
+  int i, fpus, fptag, nb_xmm_regs;
+  CPU86_LDouble tmp;
+  target_ulong addr;
+
+  kenv->fpuc = lduw_(ptr);
+  fpus = lduw_(ptr + 2);
+  fptag = lduw_(ptr + 4);
+  kenv->fpstt = (fpus >> 11) & 7;
+  kenv->fpus = fpus & ~0x3800;
+  fptag ^= 0xff;
+  for(i = 0;i < 8; i++) {
+    kenv->fptags[i] = ((fptag >> i) & 1);
+  }
+
+  addr = ((target_ulong)*ptr) + 0x20;
+  for(i = 0;i < 8; i++) {
+    tmp = fldt_(addr);
+    ST(i) = tmp;
+    addr += 16;
+  }
+
+  if (kenv->cr[4] & CR4_OSFXSR_MASK) {
+    /* XXX: finish it */
+    kenv->mxcsr = ldl_(ptr + 0x18);
+    //ldl(ptr + 0x1c);
+    if (kenv->hflags & HF_CS64_MASK)
+      nb_xmm_regs = 16;
+    else
+      nb_xmm_regs = 8;
+    addr = ((target_ulong)*ptr) + 0xa0;
+    /* Fast FXRESTORE leaves out the XMM registers */
+    if (!(kenv->efer & MSR_EFER_FFXSR)
+	|| (kenv->hflags & HF_CPL_MASK)
+	|| !(kenv->hflags & HF_LMA_MASK)) {
+      for(i = 0; i < nb_xmm_regs; i++) {
+	kenv->xmm_regs[i].XMM_Q(0) = ldq_((uint8_t*)&addr);
+	kenv->xmm_regs[i].XMM_Q(1) = ldq_((uint8_t*)(&addr + 8));
+	addr += 16;
+      }
+    }
+  }
+}
+
+void kemufuzzer_save(int t, unsigned int eip, int e) {
+  header_t h;
+  cpu_state_t s;
+  char outfile[PATH_MAX], tempfile[PATH_MAX];
+  file f;
+  int r, i;
+  unsigned char tmp[1024];
+  target_ulong saved_dr7;
+  CPUX86State *original_env;
+
+  /* We have to backup the original 'env' global and replace it with
+     kemufuzzer's environment. Otherwise, helper_cc_compute_all() and other
+     functions that use 'env' will fail. */
+  original_env = env;
+  env = kenv;
+
+  // Initialization
+  memset(&s, 0, sizeof(s));
+
+  // Get output file name
+  assert(getenv("KEMUFUZZER_PRE_STATE"));
+  assert(getenv("KEMUFUZZER_POST_STATE"));
+  assert(getenv("KEMUFUZZER_KERNEL_VERSION"));
+  assert(getenv("KEMUFUZZER_KERNEL_CHECKSUM"));
+  assert(getenv("KEMUFUZZER_TESTCASE_CHECKSUM"));
+
+  strncpy(tempfile, "/tmp/kemufuzzer-XXXXXX", PATH_MAX - 1);
+  strncpy(outfile, !t ? getenv("KEMUFUZZER_PRE_STATE") : getenv("KEMUFUZZER_POST_STATE"), PATH_MAX - 1);
+
+  mkstemp(tempfile);
+  f = fopen(tempfile, "w");
+  assert(f);
+
+  // Fill header
+  h.magic    = 0xefef;
+  h.version  = 0x0001;
+  h.emulator = EMULATOR_QEMU;
+  strncpy(h.kernel_version, getenv("KEMUFUZZER_KERNEL_VERSION"), sizeof(h.kernel_version));
+  strncpy(h.kernel_checksum, getenv("KEMUFUZZER_KERNEL_CHECKSUM"), sizeof(h.kernel_checksum));
+  strncpy(h.testcase_checksum, getenv("KEMUFUZZER_TESTCASE_CHECKSUM"), sizeof(h.testcase_checksum));
+  h.type     = !t ? PRE_TESTCASE : POST_TESTCASE;
+  h.mem_size = ram_size;
+  h.cpusno   = 1;
+  h.ioports[0] = KEMUFUZZER_HYPERCALL_START_TESTCASE; h.ioports[1] = KEMUFUZZER_HYPERCALL_STOP_TESTCASE;
+
+  // Dump header to disk
+  r = fwrite(f, &h, sizeof(h));
+  assert(r == sizeof(h));
+
+  // General purpose registers
+  s.regs_state.rax = kenv->regs[R_EAX];
+  s.regs_state.rbx = kenv->regs[R_EBX];
+  s.regs_state.rcx = kenv->regs[R_ECX];
+  s.regs_state.rdx = kenv->regs[R_EDX];
+  s.regs_state.rsi = kenv->regs[R_ESI];
+  s.regs_state.rdi = kenv->regs[R_EDI];
+  s.regs_state.rsp = kenv->regs[R_ESP];
+  s.regs_state.rbp = kenv->regs[R_EBP];
+
+  s.regs_state.rflags = helper_cc_compute_all(CC_OP) |	\
+    (DF & DF_MASK) |					\
+    kenv->eflags;
+
+  s.regs_state.rip = eip;
+
+  printf("RIP: %.16lx ", PAD64(eip));
+  r = cpu_memory_rw_debug(kenv, eip, tmp, 8, 0);
+  assert(r == 0);
+  for (r = 0; r < 8; r++) {
+    printf("\\x%.2x", tmp[r]);
+  }
+  printf("\n");
+  printf("RSP: %.16lx\n", PAD64(kenv->regs[R_ESP]));
+  printf("RSI: %.16lx\n", PAD64(kenv->regs[R_ESI]));
+
+  // System registers
+  s.sregs_state.cr0 = kenv->cr[0];
+  s.sregs_state.cr2 = kenv->cr[2];
+  s.sregs_state.cr3 = kenv->cr[3];
+  s.sregs_state.cr4 = kenv->cr[4];
+  s.sregs_state.dr0 = kenv->dr[0];
+  s.sregs_state.dr1 = kenv->dr[1];
+  s.sregs_state.dr2 = kenv->dr[2];
+  s.sregs_state.dr3 = kenv->dr[3];
+  s.sregs_state.dr6 = kenv->dr[6];
+  s.sregs_state.dr7 = kenv->dr[7];
+
+  // The DR7 register should have been pushed on the top of the stack -- verify
+  // this assumption
+  cpu_physical_memory_rw(kenv->regs[R_ESP]+kenv->segs[R_SS].base, 
+			 (uint8_t*) &saved_dr7, sizeof(kenv->dr[7]), 0);
+  assert(kenv->dr[7] == saved_dr7);
+
+  get_qemu_segment(s.sregs_state.cs, kenv->segs[R_CS]);
+  get_qemu_segment(s.sregs_state.ds, kenv->segs[R_DS]);
+  get_qemu_segment(s.sregs_state.es, kenv->segs[R_ES]);
+  get_qemu_segment(s.sregs_state.fs, kenv->segs[R_FS]);
+  get_qemu_segment(s.sregs_state.gs, kenv->segs[R_GS]);
+  get_qemu_segment(s.sregs_state.ss, kenv->segs[R_SS]);
+  get_qemu_segment(s.sregs_state.tr, kenv->tr);
+  // Bug in QEMU?
+  s.sregs_state.tr.type = 11;
+  get_qemu_segment(s.sregs_state.ldt, kenv->ldt);
+  get_qemu_table(s.sregs_state.idtr, kenv->idt);
+  get_qemu_table(s.sregs_state.gdtr, kenv->gdt);
+  s.sregs_state.efer = kenv->efer;
+
+  s.exception_state.vector = e;
+  s.exception_state.error_code = 0;
+
+  // Fpu
+  fxsave_((uint8_t *) &s.fpu_state);
+
+  // Dump MSR registers
+  s.msrs_state.n = sizeof(MSRs_to_save)/sizeof(int);
+  assert(s.msrs_state.n < MAX_MSRS);
+
+  // These are modified by helper_rdmsr()
+  for (i = 0; i < s.msrs_state.n; i++) {
+    s.msrs_state.msr_regs[i].idx = MSRs_to_save[i];
+    s.msrs_state.msr_regs[i].val = kemufuzzer_rdmsr(MSRs_to_save[i]);
+  }
+
+  // Dump cpu state
+  r = fwrite(f, &s, sizeof(s));
+  assert(r == sizeof(s));
+
+  // Dump mem state
+  for (i = 0; i < ram_size; i += sizeof(tmp)) {
+    memset(tmp, 0, sizeof(tmp));
+    cpu_physical_memory_rw(i, tmp, sizeof(tmp), 0);
+    r = fwrite(f, &tmp, sizeof(tmp));
+    assert(r == sizeof(tmp));
+  }
+
+  fclose(f);
+
+  rename(tempfile, outfile);
+  printf("Dumped CPU & MEM state to (%s -> %s)\n", tempfile, outfile);
+
+  /* Restore original CPU environment */
+  env = original_env;
+}
+
+void kemufuzzer_load(void)
+{
+  unsigned int r, i;
+  char *fname;
+  header_t h;
+  cpu_state_t s;
+  file f;
+  unsigned char tmp[1024];
+
+  fname = getenv("KEMUFUZZER_INPUT_STATE");
+  if (!fname) {
+    printf("No initial environment state\n");
+    return;
+  }
+
+  // Load state from disk
+  f = fopen(fname, "r");
+  assert(f);
+
+  r = fread(f, &h, sizeof(h));
+  assert(r == sizeof(h));
+
+  // Sanity checks
+  assert(h.magic == EXPECTED_MAGIC);
+  assert(h.version == EXPECTED_VERSION);
+  assert(h.cpusno == 1);
+  assert(h.mem_size == ram_size);
+
+  r = fread(f, &s, sizeof(s));
+  assert(r == sizeof(s));
+
+  // Load registers
+  kenv->regs[R_EAX] = s.regs_state.rax;
+  kenv->regs[R_EBX] = s.regs_state.rbx;
+  kenv->regs[R_ECX] = s.regs_state.rcx;
+  kenv->regs[R_EDX]= s.regs_state.rdx;
+  kenv->regs[R_ESI]= s.regs_state.rsi;
+  kenv->regs[R_EDI]= s.regs_state.rdi;
+  kenv->regs[R_ESP]= s.regs_state.rsp;
+  kenv->regs[R_EBP]= s.regs_state.rbp;
+  /* Do not load RIP */
+
+  kenv->eflags = s.regs_state.rflags;
+
+#if 0
+  kenv->regs[8]  = s.regs_state.r8;
+  kenv->regs[9]  = s.regs_state.r9;
+  kenv->regs[10] = s.regs_state.r10;
+  kenv->regs[11] = s.regs_state.r11;
+  kenv->regs[12] = s.regs_state.r12;
+  kenv->regs[13] = s.regs_state.r13;
+  kenv->regs[14] = s.regs_state.r14;
+  kenv->regs[15] = s.regs_state.r15;
+#endif
+
+  // Load Sregisters
+  set_qemu_segment(kenv->segs[R_CS], s.sregs_state.cs);
+  set_qemu_segment(kenv->segs[R_DS], s.sregs_state.ds);
+  set_qemu_segment(kenv->segs[R_ES], s.sregs_state.es);
+  set_qemu_segment(kenv->segs[R_FS], s.sregs_state.fs);
+  set_qemu_segment(kenv->segs[R_GS], s.sregs_state.gs);
+  set_qemu_segment(kenv->segs[R_SS], s.sregs_state.ss);
+
+  set_qemu_segment(kenv->tr,  s.sregs_state.tr);
+  set_qemu_segment(kenv->ldt, s.sregs_state.ldt);
+
+  set_qemu_table(kenv->idt, s.sregs_state.idtr);
+  set_qemu_table(kenv->gdt, s.sregs_state.gdtr);
+
+  kenv->cr[0] = s.sregs_state.cr0;
+  kenv->cr[2] = s.sregs_state.cr2;
+  kenv->cr[3] = s.sregs_state.cr3;
+  kenv->cr[4] = s.sregs_state.cr4;
+
+  kenv->dr[0] = s.sregs_state.dr0;
+  kenv->dr[1] = s.sregs_state.dr1;
+  kenv->dr[2] = s.sregs_state.dr2;
+  kenv->dr[3] = s.sregs_state.dr3;
+
+  kenv->efer  = s.sregs_state.efer;
+
+  // Load fpu
+  fxrstor_((uint8_t *) &s.fpu_state);
+
+  // Load msrs
+  for (r=0; r<s.msrs_state.n; r++) {
+    kemufuzzer_wrmsr(s.msrs_state.msr_regs[r].idx, s.msrs_state.msr_regs[r].val);
+  }
+
+  // Load mem state
+  for (i = 0; i < h.mem_size; i += sizeof(tmp)) {
+    r = fread(f, &tmp, sizeof(tmp));
+    assert(r == sizeof(tmp));
+    cpu_physical_memory_rw(i, tmp, sizeof(tmp), 1);
+  }
+
+  fclose(f);
+}
+
+uint64_t kemufuzzer_rdmsr(uint32_t index)
+{
+  uint64_t val;
+  switch(index) {
+  case MSR_IA32_SYSENTER_CS:
+    val = kenv->sysenter_cs;
+    break;
+  case MSR_IA32_SYSENTER_ESP:
+    val = kenv->sysenter_esp;
+    break;
+  case MSR_IA32_SYSENTER_EIP:
+    val = kenv->sysenter_eip;
+    break;
+  case MSR_IA32_APICBASE:
+    val = cpu_get_apic_base(kenv);
+    break;
+  case MSR_EFER:
+    val = kenv->efer;
+    break;
+  case MSR_STAR:
+    val = kenv->star;
+    break;
+  case MSR_PAT:
+    val = kenv->pat;
+    break;
+  case MSR_VM_HSAVE_PA:
+    val = kenv->vm_hsave;
+    break;
+  case MSR_IA32_PERF_STATUS:
+    /* tsc_increment_by_tick */
+    val = 1000ULL;
+    /* CPU multiplier */
+    val |= (((uint64_t)4ULL) << 40);
+    break;
+  default:
+    printf("[!] unknown MSR #%.8x\n", index);
+    assert(0);
+  }
+
+  return val;
+}
+
+void kemufuzzer_wrmsr(uint32_t index, uint64_t val)
+{
+  switch(index) {
+  case MSR_IA32_SYSENTER_CS:
+    kenv->sysenter_cs = val & 0xffff;
+    break;
+  case MSR_IA32_SYSENTER_ESP:
+    kenv->sysenter_esp = val;
+    break;
+  case MSR_IA32_SYSENTER_EIP:
+    kenv->sysenter_eip = val;
+    break;
+  case MSR_IA32_APICBASE:
+    cpu_set_apic_base(kenv, val);
+    break;
+  case MSR_EFER:
+    {
+      uint64_t update_mask;
+      update_mask = 0;
+      if (kenv->cpuid_ext2_features & CPUID_EXT2_SYSCALL)
+	update_mask |= MSR_EFER_SCE;
+      if (kenv->cpuid_ext2_features & CPUID_EXT2_LM)
+	update_mask |= MSR_EFER_LME;
+      if (kenv->cpuid_ext2_features & CPUID_EXT2_FFXSR)
+	update_mask |= MSR_EFER_FFXSR;
+      if (kenv->cpuid_ext2_features & CPUID_EXT2_NX)
+	update_mask |= MSR_EFER_NXE;
+      if (kenv->cpuid_ext3_features & CPUID_EXT3_SVM)
+	update_mask |= MSR_EFER_SVME;
+      if (kenv->cpuid_ext2_features & CPUID_EXT2_FFXSR)
+	update_mask |= MSR_EFER_FFXSR;
+      cpu_load_efer(kenv, (kenv->efer & ~update_mask) |
+		    (val & update_mask));
+    }
+    break;
+  case MSR_STAR:
+    kenv->star = val;
+    break;
+  case MSR_PAT:
+    kenv->pat = val;
+    break;
+  case MSR_VM_HSAVE_PA:
+    kenv->vm_hsave = val;
+    break;
+#ifdef TARGET_X86_64
+  case MSR_LSTAR:
+    kenv->lstar = val;
+    break;
+  case MSR_CSTAR:
+    kenv->cstar = val;
+    break;
+  case MSR_FMASK:
+    kenv->fmask = val;
+    break;
+  case MSR_FSBASE:
+    kenv->segs[R_FS].base = val;
+    break;
+  case MSR_GSBASE:
+    kenv->segs[R_GS].base = val;
+    break;
+  case MSR_KERNELGSBASE:
+    kenv->kernelgsbase = val;
+    break;
+#endif
+  case MSR_MTRRphysBase(0):
+  case MSR_MTRRphysBase(1):
+  case MSR_MTRRphysBase(2):
+  case MSR_MTRRphysBase(3):
+  case MSR_MTRRphysBase(4):
+  case MSR_MTRRphysBase(5):
+  case MSR_MTRRphysBase(6):
+  case MSR_MTRRphysBase(7):
+    kenv->mtrr_var[((uint32_t)ECX - MSR_MTRRphysBase(0)) / 2].base = val;
+    break;
+  case MSR_MTRRphysMask(0):
+  case MSR_MTRRphysMask(1):
+  case MSR_MTRRphysMask(2):
+  case MSR_MTRRphysMask(3):
+  case MSR_MTRRphysMask(4):
+  case MSR_MTRRphysMask(5):
+  case MSR_MTRRphysMask(6):
+  case MSR_MTRRphysMask(7):
+    kenv->mtrr_var[((uint32_t)ECX - MSR_MTRRphysMask(0)) / 2].mask = val;
+    break;
+  case MSR_MTRRfix64K_00000:
+    kenv->mtrr_fixed[(uint32_t)ECX - MSR_MTRRfix64K_00000] = val;
+    break;
+  case MSR_MTRRfix16K_80000:
+  case MSR_MTRRfix16K_A0000:
+    kenv->mtrr_fixed[(uint32_t)ECX - MSR_MTRRfix16K_80000 + 1] = val;
+    break;
+  case MSR_MTRRfix4K_C0000:
+  case MSR_MTRRfix4K_C8000:
+  case MSR_MTRRfix4K_D0000:
+  case MSR_MTRRfix4K_D8000:
+  case MSR_MTRRfix4K_E0000:
+  case MSR_MTRRfix4K_E8000:
+  case MSR_MTRRfix4K_F0000:
+  case MSR_MTRRfix4K_F8000:
+    kenv->mtrr_fixed[(uint32_t)ECX - MSR_MTRRfix4K_C0000 + 3] = val;
+    break;
+  case MSR_MTRRdefType:
+    kenv->mtrr_deftype = val;
+    break;
+  case MSR_MCG_STATUS:
+    kenv->mcg_status = val;
+    break;
+  case MSR_MCG_CTL:
+    if ((kenv->mcg_cap & MCG_CTL_P)
+	&& (val == 0 || val == ~(uint64_t)0))
+      kenv->mcg_ctl = val;
+    break;
+  default:
+    if ((uint32_t)ECX >= MSR_MC0_CTL
+	&& (uint32_t)ECX < MSR_MC0_CTL + (4 * kenv->mcg_cap & 0xff)) {
+      uint32_t offset = (uint32_t)ECX - MSR_MC0_CTL;
+      if ((offset & 0x3) != 0
+	  || (val == 0 || val == ~(uint64_t)0))
+	kenv->mce_banks[offset] = val;
+      break;
+    }
+    /* XXX: exception ? */
+    break;
+  }
+}
+
+void kemufuzzer_ioport_start(void *opaque, uint32_t addr, uint32_t val)
+{
+  unsigned char e[3];
+  int r;
+
+  assert(kenv);
+
+  printf("**** TESTCASE STARTED **** addr: %.8x, val: %.8x, eip: %.8x\n", addr, val, kenv->eip + 2);
+
+  // eip = eip + cs_base because testcases are executed in separate tasks
+  r = cpu_memory_rw_debug(kenv, kenv->eip + kenv->segs[R_CS].base, e, 2, 0);
+  assert(r == 0);
+  assert(e[0] == 0xe6 && e[1] == KEMUFUZZER_HYPERCALL_START_TESTCASE);
+
+  /* Enable tracing */
+  kemufuzzer_state.signalled = 0;
+  // cpu_single_step(kenv, 1);
+
+  /* Restore initial state */
+  kemufuzzer_load();
+
+  /* Dump current state */
+  kemufuzzer_save(KEMUFUZZER_PRE_STATE, kenv->eip + 2, EXCEPTION_NONE);
+}
+
+
+void kemufuzzer_ioport_stop(void *opaque, uint32_t addr, uint32_t val)
+{
+  unsigned char e[8];
+  int r;
+
+  if (kemufuzzer_state.signalled)
+    return;
+
+  // eip = eip + cs_base because testcases are executed in separate tasks
+  r = cpu_memory_rw_debug(kenv, kenv->eip + kenv->segs[R_CS].base, e, 8, 0);
+  assert(r == 0);
+  assert(e[0] == 0xe6 && e[1] == KEMUFUZZER_HYPERCALL_STOP_TESTCASE);
+  printf("**** TESTCASE COMPLETED (INTERRUPT) **** eip: %.8x exc: %x\n", kenv->eip, *((uint16_t *) (e + 4)));
+
+  /* Disable tracing */
+  kemufuzzer_state.signalled = 1;
+
+  /* Dump current state */
+  kemufuzzer_save(KEMUFUZZER_POST_STATE, kenv->eip, *((uint16_t *) (e + 4)));
+}
+
+
+void kemufuzzer_init(CPUState *e)
+{
+  if (kemufuzzer_state.initialized) {
+    /* Already initialized */
+    return;
+  }
+
+  kenv = e;
+  kemufuzzer_state.initialized = 1;
+
+  /* Register our fake I/O port */
+  register_ioport_write(KEMUFUZZER_HYPERCALL_START_TESTCASE, 1, 1, kemufuzzer_ioport_start, NULL);
+  register_ioport_write(KEMUFUZZER_HYPERCALL_STOP_TESTCASE, 1, 1, kemufuzzer_ioport_stop, NULL);
+}
+
+#undef kenv
diff -Naur qemu-0.12.4+dfsg/README.KEmuFuzzer qemu-0.12.4+dfsg-kemufuzzer/README.KEmuFuzzer
--- qemu-0.12.4+dfsg/README.KEmuFuzzer	1970-01-01 01:00:00.000000000 +0100
+++ qemu-0.12.4+dfsg-kemufuzzer/README.KEmuFuzzer	2010-07-07 12:02:26.217117067 +0200
@@ -0,0 +1 @@
+./configure --disable-linux-user --disable-darwin-user --target-list=i386-softmmu --enable-kemufuzzer --disable-kvm
diff -Naur qemu-0.12.4+dfsg/x86_cpustate.h qemu-0.12.4+dfsg-kemufuzzer/x86_cpustate.h
--- qemu-0.12.4+dfsg/x86_cpustate.h	1970-01-01 01:00:00.000000000 +0100
+++ qemu-0.12.4+dfsg-kemufuzzer/x86_cpustate.h	2010-07-07 12:02:26.204956982 +0200
@@ -0,0 +1,183 @@
+// This file is part of KEmuFuzzer.
+// 
+// KEmuFuzzer is free software: you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation, either version 3 of the License, or (at your option)
+// any later version.
+// 
+// KEmuFuzzer is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+// FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+// details.
+// 
+// You should have received a copy of the GNU General Public License along with
+// KEmuFuzzer.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef CPUSTATE_H
+#define CPUSTATE_H
+
+#include <stdint.h>
+#include "x86.h"
+
+#define KEMUFUZZER_HYPERCALL_START_TESTCASE  0x23
+#define KEMUFUZZER_HYPERCALL_STOP_TESTCASE   0x45
+
+#define EXPECTED_MAGIC    0xEFEF
+#define EXPECTED_VERSION  0x0001
+
+#define CPU_STATE_MAGIC          0xEFEF
+#define CPU_STATE_VERSION        0x0001
+#define MAX_MSRS                   0x20
+#define HYPERCALL_LEN               0x2	// length of a "hypercall" instruction (in bytes)
+
+static int MSRs_to_save[] = {
+  X86_MSR_IA32_SYSENTER_CS,
+  X86_MSR_IA32_SYSENTER_ESP,
+  X86_MSR_IA32_SYSENTER_EIP,
+  X86_MSR_IA32_APICBASE,
+  X86_MSR_EFER,
+  X86_MSR_STAR,
+  X86_MSR_PAT,
+  X86_MSR_VM_HSAVE_PA,
+  X86_MSR_IA32_PERF_STATUS,  
+};
+
+typedef uint64_t reg64_t;
+typedef uint32_t reg32_t;
+typedef uint16_t reg16_t;
+
+typedef struct __attribute__((__packed__)) {
+  uint64_t mantissa;
+  uint16_t expsign;
+  uint8_t  reserved[6];
+} fpust_t;
+
+typedef struct __attribute__((__packed__)) {
+  uint8_t data[16];
+} fpuxmm_t;
+
+typedef struct __attribute__((__packed__)) {
+  uint16_t fcw;
+  uint16_t fsw;
+  uint8_t  ftw;
+  uint8_t  unused;
+  uint16_t fop;
+  uint32_t fpuip;
+  uint16_t cs;
+  uint16_t reserved0;
+  uint32_t fpudp;
+  uint16_t ds;
+  uint16_t reserved1;
+  uint32_t mxcsr;
+  uint32_t mxcsr_mask;
+
+  fpust_t st[8];                // STx/MMx
+  fpuxmm_t xmm[8];
+  fpuxmm_t xmm_reserved[14];
+} fpu_state_t;
+
+typedef enum {
+  EMULATOR_QEMU = 0,
+  EMULATOR_BOCHS,
+  EMULATOR_VIRTUALBOX,
+  EMULATOR_VMWARE,
+  EMULATOR_KVM
+} emulator_t;
+
+typedef enum {
+  PRE_TESTCASE = 0,
+  POST_TESTCASE = 1,
+  CRASH_TESTCASE = 0x10,
+  TIMEOUT_TESTCASE = 0x20,
+  IO_TESTCASE = 0x40
+} type_t;
+
+typedef struct __attribute__ ((__packed__)) {
+  uint16_t    magic;
+  uint16_t    version;
+  emulator_t  emulator;
+  char        kernel_version[16];
+  char        kernel_checksum[64];
+  char        testcase_checksum[64];
+  type_t      type;
+  uint8_t     cpusno;
+  uint32_t    mem_size;
+  uint8_t     ioports[2];
+} header_t;
+
+typedef struct __attribute__ ((__packed__)) {
+  reg64_t rax, rbx, rcx, rdx, rsi, rdi, rsp, rbp, r8, r9, r10;
+  reg64_t r11, r12, r13, r14, r15, rip, rflags;
+} regs_state_t;
+
+typedef struct __attribute__ ((__packed__)) {
+  uint64_t base;
+  uint32_t limit;
+  uint16_t selector;
+  uint8_t type;
+  uint8_t present, dpl, db, s, l, g, avl;
+  uint8_t unusable;
+} segment_reg_t;
+
+typedef struct __attribute__ ((__packed__)) {
+  uint64_t base;
+  uint16_t limit;
+} dtable_reg_t;
+
+typedef struct __attribute__ ((__packed__)) {
+  segment_reg_t cs, ds, es, fs, gs, ss;
+  segment_reg_t tr, ldt;
+  dtable_reg_t idtr, gdtr;
+  uint64_t cr0, cr1, cr2, cr3, cr4, cr8;
+  uint64_t dr0, dr1, dr2, dr3, dr6, dr7;
+  uint64_t efer;
+} sregs_state_t;
+
+typedef struct __attribute__ ((__packed__)) {
+  uint32_t idx;
+  uint64_t val;
+} msr_reg_t;
+
+typedef struct __attribute__ ((__packed__)) {
+  uint32_t n;
+  msr_reg_t msr_regs[MAX_MSRS];
+} msrs_state_t;
+
+typedef struct __attribute__ ((__packed__)) {
+  uint32_t vector;
+  uint32_t error_code;
+} exception_state_t;
+
+typedef struct __attribute__ ((__packed__)) {
+  // FPU state
+  fpu_state_t fpu_state;
+
+  // General purpose registers state
+  regs_state_t regs_state;
+
+  // Special registers state
+  sregs_state_t sregs_state;
+
+  // Exception state
+  exception_state_t exception_state;
+
+  // MSR registers state
+  msrs_state_t msrs_state;
+} cpu_state_t;
+
+// HEADER + CPU[0] + CPU[1] + .... + MEM
+
+
+#ifndef DONT_GZIP_STATE
+#define file   gzFile
+#define fwrite(a,b,c) gzwrite(a,b,c)
+#define fread(a,b,c) gzread(a,b,c)
+#define fclose(a) gzclose(a)
+#define fopen(a,b) gzopen(a,b)
+#else
+#define file   FILE *
+#define fwrite(a,b,c) (fwrite(b,c,1,a) * c)
+#define fread(a,b,c)  (fread(b,c,1,a) * c)
+#endif
+
+#endif
diff -Naur qemu-0.12.4+dfsg/x86.h qemu-0.12.4+dfsg-kemufuzzer/x86.h
--- qemu-0.12.4+dfsg/x86.h	1970-01-01 01:00:00.000000000 +0100
+++ qemu-0.12.4+dfsg-kemufuzzer/x86.h	2010-07-07 12:02:26.252617662 +0200
@@ -0,0 +1,93 @@
+// This file is part of KEmuFuzzer.
+// 
+// KEmuFuzzer is free software: you can redistribute it and/or modify it under
+// the terms of the GNU General Public License as published by the Free
+// Software Foundation, either version 3 of the License, or (at your option)
+// any later version.
+// 
+// KEmuFuzzer is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+// FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+// details.
+// 
+// You should have received a copy of the GNU General Public License along with
+// KEmuFuzzer.  If not, see <http://www.gnu.org/licenses/>.
+
+#ifndef _KEMU_X86
+#define _KEMU_X86
+
+#ifdef __LP64__
+#define ADDR(x) ((uint64_t) (x))
+#define PTR(x) ((uint64_t *) (x))
+#define CPU_64_BIT
+#define CPU_BITS 64
+#else
+#define ADDR(x) ((uint32_t) (x))
+#define PTR(x) ((uint32_t *) (x))
+#define CPU_32_BIT
+#define CPU_BITS 32
+#endif
+
+#define PAD64(x) ((uint64_t) (x))
+
+/* trap/fault mnemonics */
+#define EXCEPTION_DIVIDE_ERROR      0
+#define EXCEPTION_DEBUG             1
+#define EXCEPTION_NMI               2
+#define EXCEPTION_INT3              3
+#define EXCEPTION_OVERFLOW          4
+#define EXCEPTION_BOUNDS            5
+#define EXCEPTION_INVALID_OP        6
+#define EXCEPTION_NO_DEVICE         7
+#define EXCEPTION_DOUBLE_FAULT      8
+#define EXCEPTION_COPRO_SEG         9
+#define EXCEPTION_INVALID_TSS      10
+#define EXCEPTION_NO_SEGMENT       11
+#define EXCEPTION_STACK_ERROR      12
+#define EXCEPTION_GP_FAULT         13
+#define EXCEPTION_PAGE_FAULT       14
+#define EXCEPTION_SPURIOUS_INT     15
+#define EXCEPTION_COPRO_ERROR      16
+#define EXCEPTION_ALIGNMENT_CHECK  17
+#define EXCEPTION_MACHINE_CHECK    18
+#define EXCEPTION_SIMD_ERROR       19
+#define EXCEPTION_DEFERRED_NMI     31
+#define EXCEPTION_NONE             0xFFFF
+
+/* cr0 bits */
+#define CR0_PE         (1u << 0)
+#define CR0_MP         (1u << 1)
+#define CR0_EM         (1u << 2)
+#define CR0_TS         (1u << 3)
+#define CR0_ET         (1u << 4)
+#define CR0_NE         (1u << 5)
+#define CR0_WP         (1u << 16)
+#define CR0_AM         (1u << 18)
+#define CR0_NW         (1u << 29)
+#define CR0_CD         (1u << 30)
+#define CR0_PG         (1u << 31)
+
+#define CR4_PAE        (1u << 5)
+
+/* rflags */
+#define RFLAGS_RESERVED_MASK    2
+
+#define RFLAGS_TRAP    (1u << 8)
+
+#define EFER_LME       (1u << 8)
+
+#define PAGE_4K_MASK 0xfffff000
+#define PAGE_4K_SIZE 0x1000
+
+/* MSRs */
+#define X86_MSR_IA32_SYSENTER_CS            0x174
+#define X86_MSR_IA32_SYSENTER_ESP           0x175
+#define X86_MSR_IA32_SYSENTER_EIP           0x176
+#define X86_MSR_IA32_APICBASE               0x1b
+#define X86_MSR_EFER                        0xc0000080
+#define X86_MSR_STAR                        0xc0000081
+#define X86_MSR_PAT                         0x277
+#define X86_MSR_VM_HSAVE_PA                 0xc0010117
+#define X86_MSR_IA32_PERF_STATUS            0x198
+
+#endif /* _KEMU_X86 */
